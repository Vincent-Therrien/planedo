<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exoplanet Viewer</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Exoplanet Position Viewer</h1>
      <p class="subtitle">3D map of confirmed exoplanets</p>

      <div class="controls">
        <div class="control">
          <label for="distance-range">Max distance (ly)</label>
          <input id="distance-range" type="range" min="2" max="100" step="0.1" value="8" />
        </div>

        <div class="control">
          <label for="planet-type">Planet type</label>
          <select id="planet-type">
            <option value="all">All</option>
            <option value="gas-giant">Gas Giant</option>
            <option value="neptune-like">Neptune-like</option>
            <option value="super-earth">Super Earth</option>
            <option value="terrestrial">Terrestrial</option>
          </select>
        </div>

        <div class="control">
          <label for="show-labels">Show labels</label>
          <select id="show-labels">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div class="control axis-toggle">
          <label for="show-axes">Show axes</label>
          <input id="show-axes" type="checkbox" />
        </div>
      </div>

      <section class="planet-info" aria-live="polite">
        <h2>Selection</h2>
        <p id="selection-status">Click a sphere to see details.</p>
        <p><strong>Name:</strong> <span id="planet-name">None</span></p>
        <p><strong>Type:</strong> <span id="planet-class">-</span></p>
        <p><strong>Distance:</strong> <span id="planet-distance">-</span></p>
      </section>
    </aside>

    <main class="canvas-wrap">
      <canvas id="scene-canvas" aria-label="3D exoplanet scene"></canvas>
    </main>
  </div>

  <script>
    const canvas = document.getElementById("scene-canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("selection-status");
    const nameEl = document.getElementById("planet-name");
    const classEl = document.getElementById("planet-class");
    const distanceEl = document.getElementById("planet-distance");
    const distanceRangeEl = document.getElementById("distance-range");
    const showAxesEl = document.getElementById("show-axes");
    const PARSEC_TO_LIGHTYEAR = 3.26156;

    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isPanMode = false;
    let dragDistancePx = 0;

    const fov = Math.PI / 3;
    const near = 0.1;
    const target = { x: 0, y: 0, z: 0 };
    let cameraDistance = 250;
    let yaw = 0;
    let pitch = 0.15;
    let axisRange = 100;
    let planets = [];
    let projectedPlanetsForPicking = [];
    let selectedPlanetName = null;

    const tickSize = 1.1;
    const axisStep = 50;

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function normalize(v) {
      const len = Math.hypot(v.x, v.y, v.z) || 1;
      return { x: v.x / len, y: v.y / len, z: v.z / len };
    }

    function cross(a, b) {
      return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
      };
    }

    function dot(a, b) {
      return a.x * b.x + a.y * b.y + a.z * b.z;
    }

    function getCameraState() {
      const cosPitch = Math.cos(pitch);
      const cam = {
        x: target.x + cameraDistance * cosPitch * Math.sin(yaw),
        y: target.y + cameraDistance * Math.sin(pitch),
        z: target.z + cameraDistance * cosPitch * Math.cos(yaw)
      };

      const forward = normalize({
        x: target.x - cam.x,
        y: target.y - cam.y,
        z: target.z - cam.z
      });

      let right = cross(forward, { x: 0, y: 1, z: 0 });
      if (Math.hypot(right.x, right.y, right.z) < 1e-6) {
        right = { x: 1, y: 0, z: 0 };
      } else {
        right = normalize(right);
      }

      const up = normalize(cross(right, forward));
      return { cam, forward, right, up };
    }

    function drawDot(x, y, radius, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function project(point, cameraState, width, height, focal) {
      const rel = {
        x: point.x - cameraState.cam.x,
        y: point.y - cameraState.cam.y,
        z: point.z - cameraState.cam.z
      };

      const cx = dot(rel, cameraState.right);
      const cy = dot(rel, cameraState.up);
      const cz = dot(rel, cameraState.forward);

      if (cz <= near) {
        return null;
      }

      const scale = focal / cz;
      return {
        x: width * 0.5 + cx * scale,
        y: height * 0.5 - cy * scale,
        scale,
        depth: cz
      };
    }

    function draw3DLine(a, b, cameraState, width, height, focal, lineWidth) {
      const pa = project(a, cameraState, width, height, focal);
      const pb = project(b, cameraState, width, height, focal);
      if (!pa || !pb) {
        return;
      }

      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }

    function drawAxes(cameraState, width, height, focal) {
      ctx.strokeStyle = "#ffffff";

      draw3DLine(
        { x: -axisRange, y: 0, z: 0 },
        { x: axisRange, y: 0, z: 0 },
        cameraState,
        width,
        height,
        focal,
        1
      );
      draw3DLine(
        { x: 0, y: -axisRange, z: 0 },
        { x: 0, y: axisRange, z: 0 },
        cameraState,
        width,
        height,
        focal,
        1
      );
      draw3DLine(
        { x: 0, y: 0, z: -axisRange },
        { x: 0, y: 0, z: axisRange },
        cameraState,
        width,
        height,
        focal,
        1
      );

      ctx.globalAlpha = 0.8;
      for (let i = -axisRange; i <= axisRange; i += axisStep) {
        if (i === 0) {
          continue;
        }

        draw3DLine(
          { x: i, y: -tickSize, z: 0 },
          { x: i, y: tickSize, z: 0 },
          cameraState,
          width,
          height,
          focal,
          1
        );
        draw3DLine(
          { x: -tickSize, y: i, z: 0 },
          { x: tickSize, y: i, z: 0 },
          cameraState,
          width,
          height,
          focal,
          1
        );
        draw3DLine(
          { x: 0, y: -tickSize, z: i },
          { x: 0, y: tickSize, z: i },
          cameraState,
          width,
          height,
          focal,
          1
        );
      }
      ctx.globalAlpha = 1;
    }

    function parsePlanetsCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      const parsed = [];

      for (let i = 1; i < lines.length; i += 1) {
        const parts = lines[i].split(",");
        if (parts.length < 5) {
          continue;
        }

        const name = parts[1].trim();
        const raDeg = Number(parts[2]);
        const decDeg = Number(parts[3]);
        const distPc = Number(parts[4]);
        if (!Number.isFinite(raDeg) || !Number.isFinite(decDeg) || !Number.isFinite(distPc)) {
          continue;
        }

        const distanceLy = distPc * PARSEC_TO_LIGHTYEAR;
        const ra = (raDeg * Math.PI) / 180;
        const dec = (decDeg * Math.PI) / 180;
        const cosDec = Math.cos(dec);

        parsed.push({
          name,
          distanceLy,
          x: distanceLy * cosDec * Math.cos(ra),
          y: distanceLy * Math.sin(dec),
          z: distanceLy * cosDec * Math.sin(ra)
        });
      }

      return parsed;
    }

    async function loadPlanets() {
      try {
        if (window.location.protocol === "file:") {
          throw new Error(
            "This page is opened with file://, so browsers block reading planets.csv. Start a local server and open http://localhost instead."
          );
        }

        const response = await fetch("./planets.csv", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load planets.csv (${response.status})`);
        }

        const csvText = await response.text();
        planets = [
          { name: "Earth", distanceLy: 0, x: 0, y: 0, z: 0, isEarth: true },
          ...parsePlanetsCsv(csvText).map((planet) => ({ ...planet, isEarth: false }))
        ];
        const maxDistanceLy = planets.reduce(
          (max, planet) => Math.max(max, planet.distanceLy),
          0
        );
        axisRange = Math.max(100, Math.ceil(maxDistanceLy / axisStep) * axisStep);

        distanceRangeEl.min = "1";
        distanceRangeEl.max = String(Math.ceil(maxDistanceLy));
        distanceRangeEl.step = "1";
        distanceRangeEl.value = String(Math.max(1, Math.min(100, Math.ceil(maxDistanceLy))));

        statusEl.textContent = `Loaded ${planets.length} planets. Drag to orbit. Shift+drag to pan.`;
        distanceEl.textContent = `${distanceRangeEl.value} ly max`;
        render();
      } catch (error) {
        statusEl.textContent = `Could not load planets.csv: ${error.message}`;
        classEl.textContent = "Run local server";
        nameEl.textContent = "localhost:8000";
        distanceEl.textContent = "python -m http.server 8000";
      }
    }

    function render() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      canvas.width = width;
      canvas.height = height;

      ctx.clearRect(0, 0, width, height);
      const focal = (height * 0.5) / Math.tan(fov * 0.5);
      const cameraState = getCameraState();
      if (showAxesEl.checked) {
        drawAxes(cameraState, width, height, focal);
      }

      const maxDistanceLy = Number(distanceRangeEl.value);
      const projected = planets
        .filter((planet) => planet.distanceLy <= maxDistanceLy)
        .map((planet) => {
          const p = project(planet, cameraState, width, height, focal);
          if (!p) {
            return null;
          }
          return { ...planet, ...p, radius: clamp(0.4 * p.scale, 1.2, 4.5) };
        })
        .filter(Boolean)
        .sort((a, b) => b.depth - a.depth);

      projectedPlanetsForPicking = projected.map((planet) => ({
        name: planet.name,
        x: planet.x,
        y: planet.y,
        radius: planet.radius,
        depth: planet.depth,
        distanceLy: planet.distanceLy
      }));

      projected.forEach((planet) => {
        if (planet.isEarth) {
          return;
        }
        let color = "#ffffff";
        if (selectedPlanetName === planet.name) {
          color = "#ff2a2a";
        }
        drawDot(planet.x, planet.y, planet.radius, color);
      });

      const earth = projected.find((planet) => planet.isEarth);
      if (earth) {
        const earthColor = selectedPlanetName === earth.name ? "#ff2a2a" : "#2d7dff";
        drawDot(earth.x, earth.y, Math.max(earth.radius, 4), earthColor);
      }
      distanceEl.textContent = `${maxDistanceLy} ly max (${projected.length}/${planets.length} shown)`;
    }

    function selectPlanetAt(screenX, screenY) {
      let selected = null;
      let bestDepth = Infinity;
      let bestDistSq = Infinity;

      for (const planet of projectedPlanetsForPicking) {
        const dx = screenX - planet.x;
        const dy = screenY - planet.y;
        const distSq = dx * dx + dy * dy;
        const pickRadius = Math.max(6, planet.radius + 3);
        if (distSq > pickRadius * pickRadius) {
          continue;
        }

        if (planet.depth < bestDepth || (planet.depth === bestDepth && distSq < bestDistSq)) {
          selected = planet;
          bestDepth = planet.depth;
          bestDistSq = distSq;
        }
      }

      if (!selected) {
        selectedPlanetName = null;
        statusEl.textContent = "No planet selected.";
        nameEl.textContent = "None";
        render();
        return;
      }

      selectedPlanetName = selected.name;
      statusEl.textContent = `Selected ${selected.name}.`;
      nameEl.textContent = selected.name;
      render();
    }

    canvas.addEventListener("mousedown", (event) => {
      if (event.button !== 0 && event.button !== 1) {
        return;
      }
      isDragging = true;
      dragDistancePx = 0;
      isPanMode = event.shiftKey || event.button === 1;
      if (event.button === 1) {
        event.preventDefault();
      }
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      canvas.style.cursor = "grabbing";
    });

    window.addEventListener("mousemove", (event) => {
      if (!isDragging) {
        return;
      }
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      dragDistancePx += Math.hypot(dx, dy);
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      if (isPanMode) {
        const cameraState = getCameraState();
        const worldPerPixel =
          (2 * cameraDistance * Math.tan(fov * 0.5)) / canvas.clientHeight;
        target.x -= cameraState.right.x * dx * worldPerPixel;
        target.y -= cameraState.right.y * dx * worldPerPixel;
        target.z -= cameraState.right.z * dx * worldPerPixel;
        target.x += cameraState.up.x * dy * worldPerPixel;
        target.y += cameraState.up.y * dy * worldPerPixel;
        target.z += cameraState.up.z * dy * worldPerPixel;
      } else {
        yaw -= dx * 0.005;
        pitch = clamp(pitch + dy * 0.005, -1.45, 1.45);
      }

      render();
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });

    canvas.addEventListener(
      "wheel",
      (event) => {
        event.preventDefault();
        const factor = event.deltaY > 0 ? 1.08 : 0.92;
        cameraDistance = clamp(cameraDistance * factor, 10, 5000);
        render();
      },
      { passive: false }
    );

    canvas.addEventListener("click", (event) => {
      if (dragDistancePx > 4) {
        dragDistancePx = 0;
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      selectPlanetAt(x, y);
    });

    distanceRangeEl.addEventListener("input", render);

    showAxesEl.addEventListener("change", render);

    showAxesEl.checked = false;
    canvas.style.cursor = "grab";
    statusEl.textContent = "Loading planets.csv...";
    nameEl.textContent = "All planets";
    classEl.textContent = "From planets.csv";
    distanceEl.textContent = "-";

    window.addEventListener("resize", render);
    loadPlanets();
    render();
  </script>
</body>
</html>
