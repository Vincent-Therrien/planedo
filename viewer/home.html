<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exoplanet Viewer</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Exoplanet Position Viewer</h1>
      <p class="subtitle">3D map of confirmed exoplanets</p>

      <div class="controls">
        <div class="control">
          <label for="distance-range">Max distance (ly)</label>
          <input id="distance-range" type="range" min="2" max="100" step="0.1" value="8" />
        </div>

        <div class="control">
          <label for="planet-type">Planet type</label>
          <select id="planet-type">
            <option value="all">All</option>
            <option value="gas-giant">Gas Giant</option>
            <option value="neptune-like">Neptune-like</option>
            <option value="super-earth">Super Earth</option>
            <option value="terrestrial">Terrestrial</option>
          </select>
        </div>

        <div class="control">
          <label for="show-labels">Show labels</label>
          <select id="show-labels">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div class="control axis-toggle">
          <label for="show-axes">Show axes</label>
          <input id="show-axes" type="checkbox" />
        </div>
      </div>

      <section class="planet-info" aria-live="polite">
        <h2>Selection</h2>
        <p id="selection-status">Click a sphere to see details.</p>
        <p><strong>Name:</strong> <span id="planet-name">None</span></p>
        <p><strong>Type:</strong> <span id="planet-class">-</span></p>
        <p><strong>Distance:</strong> <span id="planet-distance">-</span></p>
      </section>
    </aside>

    <main class="canvas-wrap">
      <canvas id="scene-canvas" aria-label="3D exoplanet scene"></canvas>
    </main>
  </div>

  <script>
    const canvas = document.getElementById("scene-canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("selection-status");
    const nameEl = document.getElementById("planet-name");
    const classEl = document.getElementById("planet-class");
    const distanceEl = document.getElementById("planet-distance");
    const distanceRangeEl = document.getElementById("distance-range");
    const showAxesEl = document.getElementById("show-axes");
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isPanMode = false;

    const fov = Math.PI / 3;
    const near = 0.1;
    const target = { x: 0, y: 0, z: 0 };
    let distance = 8;
    let yaw = 0;
    let pitch = 0.15;

    const spheres = [
      { x: -1.8, y: 0, z: 0, r: 0.9, inner: "#cbeeff", outer: "#3a96c9" },
      { x: 1.8, y: 0, z: 0, r: 0.9, inner: "#ffe1c3", outer: "#cc7d32" }
    ];
    const axisRange = 100;
    const tickSize = 0.14;

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function normalize(v) {
      const len = Math.hypot(v.x, v.y, v.z) || 1;
      return { x: v.x / len, y: v.y / len, z: v.z / len };
    }

    function cross(a, b) {
      return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
      };
    }

    function dot(a, b) {
      return a.x * b.x + a.y * b.y + a.z * b.z;
    }

    function getCameraState() {
      const cosPitch = Math.cos(pitch);
      const cam = {
        x: target.x + distance * cosPitch * Math.sin(yaw),
        y: target.y + distance * Math.sin(pitch),
        z: target.z + distance * cosPitch * Math.cos(yaw)
      };

      const forward = normalize({
        x: target.x - cam.x,
        y: target.y - cam.y,
        z: target.z - cam.z
      });

      let right = cross(forward, { x: 0, y: 1, z: 0 });
      if (Math.hypot(right.x, right.y, right.z) < 1e-6) {
        right = { x: 1, y: 0, z: 0 };
      } else {
        right = normalize(right);
      }

      const up = normalize(cross(right, forward));
      return { cam, forward, right, up };
    }

    function drawSphere(x, y, radius, innerColor, outerColor) {
      const gradient = ctx.createRadialGradient(
        x - radius * 0.35,
        y - radius * 0.35,
        radius * 0.15,
        x,
        y,
        radius
      );
      gradient.addColorStop(0, innerColor);
      gradient.addColorStop(1, outerColor);

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function project(point, cameraState, width, height, focal) {
      const rel = {
        x: point.x - cameraState.cam.x,
        y: point.y - cameraState.cam.y,
        z: point.z - cameraState.cam.z
      };

      const cx = dot(rel, cameraState.right);
      const cy = dot(rel, cameraState.up);
      const cz = dot(rel, cameraState.forward);

      if (cz <= near) {
        return null;
      }

      const scale = focal / cz;
      return {
        x: width * 0.5 + cx * scale,
        y: height * 0.5 - cy * scale,
        scale,
        depth: cz
      };
    }

    function draw3DLine(a, b, cameraState, width, height, focal, lineWidth) {
      const pa = project(a, cameraState, width, height, focal);
      const pb = project(b, cameraState, width, height, focal);
      if (!pa || !pb) {
        return;
      }

      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }

    function drawAxes(cameraState, width, height, focal) {
      ctx.strokeStyle = "#ffffff";

      draw3DLine(
        { x: -axisRange, y: 0, z: 0 },
        { x: axisRange, y: 0, z: 0 },
        cameraState,
        width,
        height,
        focal,
        1
      );
      draw3DLine(
        { x: 0, y: -axisRange, z: 0 },
        { x: 0, y: axisRange, z: 0 },
        cameraState,
        width,
        height,
        focal,
        1
      );
      draw3DLine(
        { x: 0, y: 0, z: -axisRange },
        { x: 0, y: 0, z: axisRange },
        cameraState,
        width,
        height,
        focal,
        1
      );

      ctx.globalAlpha = 0.8;
      for (let i = -axisRange; i <= axisRange; i += 1) {
        if (i === 0) {
          continue;
        }

        draw3DLine(
          { x: i, y: -tickSize, z: 0 },
          { x: i, y: tickSize, z: 0 },
          cameraState,
          width,
          height,
          focal,
          1
        );
        draw3DLine(
          { x: -tickSize, y: i, z: 0 },
          { x: tickSize, y: i, z: 0 },
          cameraState,
          width,
          height,
          focal,
          1
        );
        draw3DLine(
          { x: 0, y: -tickSize, z: i },
          { x: 0, y: tickSize, z: i },
          cameraState,
          width,
          height,
          focal,
          1
        );
      }
      ctx.globalAlpha = 1;
    }

    function render() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      canvas.width = width;
      canvas.height = height;

      ctx.clearRect(0, 0, width, height);
      const focal = (height * 0.5) / Math.tan(fov * 0.5);
      const cameraState = getCameraState();
      if (showAxesEl.checked) {
        drawAxes(cameraState, width, height, focal);
      }

      const projected = spheres
        .map((sphere) => {
          const p = project(sphere, cameraState, width, height, focal);
          if (!p) {
            return null;
          }
          return { ...sphere, ...p, radius: sphere.r * p.scale };
        })
        .filter(Boolean)
        .sort((a, b) => b.depth - a.depth);

      projected.forEach((sphere) => {
        drawSphere(sphere.x, sphere.y, sphere.radius, sphere.inner, sphere.outer);
      });
    }

    function setDistance(nextDistance) {
      distance = clamp(nextDistance, 2, 100);
      distanceRangeEl.value = String(distance);
      render();
    }

    canvas.addEventListener("mousedown", (event) => {
      if (event.button !== 0 && event.button !== 1) {
        return;
      }
      isDragging = true;
      isPanMode = event.shiftKey || event.button === 1;
      if (event.button === 1) {
        event.preventDefault();
      }
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      canvas.style.cursor = "grabbing";
    });

    window.addEventListener("mousemove", (event) => {
      if (!isDragging) {
        return;
      }
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      if (isPanMode) {
        const cameraState = getCameraState();
        const worldPerPixel = (2 * distance * Math.tan(fov * 0.5)) / canvas.clientHeight;
        target.x -= cameraState.right.x * dx * worldPerPixel;
        target.y -= cameraState.right.y * dx * worldPerPixel;
        target.z -= cameraState.right.z * dx * worldPerPixel;
        target.x += cameraState.up.x * dy * worldPerPixel;
        target.y += cameraState.up.y * dy * worldPerPixel;
        target.z += cameraState.up.z * dy * worldPerPixel;
      } else {
        yaw -= dx * 0.005;
        pitch = clamp(pitch + dy * 0.005, -1.45, 1.45);
      }

      render();
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });

    canvas.addEventListener(
      "wheel",
      (event) => {
        event.preventDefault();
        const factor = event.deltaY > 0 ? 1.08 : 0.92;
        setDistance(distance * factor);
      },
      { passive: false }
    );

    distanceRangeEl.addEventListener("input", () => {
      setDistance(Number(distanceRangeEl.value));
    });

    showAxesEl.addEventListener("change", render);

    showAxesEl.checked = false;
    canvas.style.cursor = "grab";
    statusEl.textContent = "Drag to orbit. Hold Shift and drag to move camera.";
    nameEl.textContent = "Demo spheres";
    classEl.textContent = "Placeholder";
    distanceEl.textContent = "-";

    window.addEventListener("resize", render);
    distanceRangeEl.value = String(distance);
    render();
  </script>
</body>
</html>
