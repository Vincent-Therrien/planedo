<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exoplanet Viewer</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Exoplanet Position Viewer</h1>
      <p class="subtitle">3D map of confirmed exoplanets</p>

      <div class="controls">
        <div class="control">
          <label for="distance-range">Max distance (ly)</label>
          <input id="distance-range" type="range" min="2" max="100" step="0.1" value="8" />
          <p id="distance-summary" class="subtitle">-</p>
        </div>

        <div class="control">
          <label for="planet-type">Planet type</label>
          <select id="planet-type">
            <option value="all">All</option>
            <option value="gas-giant">Gas Giant</option>
            <option value="neptune-like">Neptune-like</option>
            <option value="super-earth">Super Earth</option>
            <option value="terrestrial">Terrestrial</option>
          </select>
        </div>

        <div class="control">
          <label for="show-labels">Show labels</label>
          <select id="show-labels">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div class="control axis-toggle">
          <label for="show-axes">Show Equatorial Grid (RA/Dec)</label>
          <input id="show-axes" type="checkbox" />
        </div>

        <div class="control axis-toggle">
          <label for="show-gc-arrow">Show Galactic Center Arrow</label>
          <input id="show-gc-arrow" type="checkbox" />
        </div>

        <div class="control">
          <button id="reset-view" type="button">Reset View to Earth</button>
        </div>
      </div>

      <section class="legend-info" aria-live="polite">
        <h2>Legend</h2>
        <p><span class="legend-swatch legend-earth"></span> Earth (Deep blue)</p>
        <p><span class="legend-swatch legend-inside"></span> Planet inside equatorial grid</p>
        <p><span class="legend-swatch legend-outside"></span> Planet outside equatorial grid</p>
        <p><span class="legend-swatch legend-selected"></span> Selected planet</p>
        <p><strong>Grid radius:</strong> <span id="grid-radius-ly">-</span></p>
      </section>

      <section class="planet-info" aria-live="polite">
        <h2>Selection</h2>
        <p id="selection-status">Click a sphere to see details.</p>
        <p><strong>Name:</strong> <span id="planet-name">None</span></p>
        <p><strong>Type:</strong> <span id="planet-class">-</span></p>
        <p><strong>RA:</strong> <span id="planet-ra">-</span></p>
        <p><strong>Dec:</strong> <span id="planet-dec">-</span></p>
        <p><strong>Distance:</strong> <span id="planet-distance">-</span></p>
      </section>
    </aside>

    <main class="canvas-wrap">
      <canvas id="scene-canvas" aria-label="3D exoplanet scene"></canvas>
    </main>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const canvas = document.getElementById("scene-canvas");
    const statusEl = document.getElementById("selection-status");
    const nameEl = document.getElementById("planet-name");
    const classEl = document.getElementById("planet-class");
    const raEl = document.getElementById("planet-ra");
    const decEl = document.getElementById("planet-dec");
    const selectionDistanceEl = document.getElementById("planet-distance");
    const distanceSummaryEl = document.getElementById("distance-summary");
    const distanceRangeEl = document.getElementById("distance-range");
    const planetTypeEl = document.getElementById("planet-type");
    const showLabelsEl = document.getElementById("show-labels");
    const showAxesEl = document.getElementById("show-axes");
    const showGalacticArrowEl = document.getElementById("show-gc-arrow");
    const gridRadiusEl = document.getElementById("grid-radius-ly");
    const resetViewEl = document.getElementById("reset-view");

    const PARSEC_TO_LIGHTYEAR = 3.26156;
    const pointRadius = 0.75;
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const raLabelTextures = [];
    const RA_BASE_RADIUS = 20;
    const RA_TARGET_SCREEN_RADIUS_PX = 250;
    const MAX_ZOOM_OUT_GRID_RADIUS_LY = 27000;
    const PLANET_MIN_SCREEN_RADIUS_PX = 1;
    const PLANET_SCREEN_RADIUS_PX = 3;
    const COLOR_EARTH = 0x0000ff;
    const COLOR_PLANET_INSIDE_GRID = 0x8fb8ff;
    const COLOR_PLANET_OUTSIDE_GRID = 0xffffff;
    const COLOR_SELECTED = 0xff0000;
    const COLOR_GALACTIC_CENTER = 0xffa500;
    const GALACTIC_CENTER_RA_DEG = (17 + (45 / 60) + (40.04 / 3600)) * 15;
    const GALACTIC_CENTER_DEC_DEG = -29 - (28.1 / 3600);
    const GALACTIC_CENTER_DISTANCE_LY = 27000;

    let axisRange = 100;
    let planets = [];
    let selectedPlanet = null;
    let pointerIsDown = false;
    let pointerMoved = false;
    let pointerDownX = 0;
    let pointerDownY = 0;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 10000);
    camera.position.set(0, 120, 250);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0, 0);

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const pointLight = new THREE.PointLight(0xffffff, 0.9);
    pointLight.position.set(120, 120, 120);
    scene.add(pointLight);

    const earthGeometry = new THREE.SphereGeometry(pointRadius * 1.4, 16, 16);
    const earthMaterial = new THREE.MeshBasicMaterial({ color: COLOR_EARTH });
    const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.userData = {
      name: "Earth",
      type: "Reference",
      distanceLy: 0,
      isEarth: true
    };
    scene.add(earthMesh);

    const gcRa = THREE.MathUtils.degToRad(GALACTIC_CENTER_RA_DEG);
    const gcDec = THREE.MathUtils.degToRad(GALACTIC_CENTER_DEC_DEG);
    const gcCosDec = Math.cos(gcDec);
    const galacticCenterDirection = new THREE.Vector3(
      gcCosDec * Math.cos(gcRa),
      Math.sin(gcDec),
      -gcCosDec * Math.sin(gcRa)
    ).normalize();
    const galacticCenterMesh = new THREE.Mesh(
      new THREE.SphereGeometry(pointRadius * 1.8, 16, 16),
      new THREE.MeshBasicMaterial({ color: COLOR_GALACTIC_CENTER })
    );
    galacticCenterMesh.position.copy(
      galacticCenterDirection.clone().multiplyScalar(GALACTIC_CENTER_DISTANCE_LY)
    );
    galacticCenterMesh.userData = {
      name: "Sagittarius A*",
      type: "Galactic Center",
      raDeg: GALACTIC_CENTER_RA_DEG,
      decDeg: GALACTIC_CENTER_DEC_DEG,
      distanceLy: GALACTIC_CENTER_DISTANCE_LY,
      isEarth: false,
      isGalacticCenter: true
    };
    scene.add(galacticCenterMesh);

    const galacticCenterArrow = new THREE.ArrowHelper(
      galacticCenterDirection,
      earthMesh.position.clone(),
      40,
      0xffaa00,
      6,
      3
    );
    galacticCenterArrow.visible = false;
    scene.add(galacticCenterArrow);

    const planetGroup = new THREE.Group();
    scene.add(planetGroup);
    const raGroup = new THREE.Group();
    raGroup.visible = false;
    scene.add(raGroup);

    function createTextSprite(label, color, fontSize = 18) {
      const canvasText = document.createElement("canvas");
      const context = canvasText.getContext("2d");
      const font = `${fontSize}px monospace`;
      context.font = font;
      const width = Math.ceil(context.measureText(label).width + 24);
      const height = Math.ceil(fontSize * 1.8);
      canvasText.width = width;
      canvasText.height = height;

      context.font = font;
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillStyle = color;
      context.fillText(label, width / 2, height / 2);

      const texture = new THREE.CanvasTexture(canvasText);
      texture.needsUpdate = true;
      raLabelTextures.push(texture);
      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false
      });
      const sprite = new THREE.Sprite(material);
      sprite.userData.isOverlayLabel = true;
      const scaleFactor = 0.06;
      sprite.scale.set(canvasText.width * scaleFactor, canvasText.height * scaleFactor, 1);
      return sprite;
    }

    function clearRaVisualizer() {
      while (raGroup.children.length > 0) {
        const obj = raGroup.children[0];
        raGroup.remove(obj);
        if (obj.geometry) {
          obj.geometry.dispose();
        }
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((material) => material.dispose());
          } else {
            obj.material.dispose();
          }
        }
      }
      while (raLabelTextures.length > 0) {
        const texture = raLabelTextures.pop();
        texture.dispose();
      }
    }

    function buildRaVisualizer() {
      clearRaVisualizer();

      const radius = RA_BASE_RADIUS;
      const segments = 256;
      const ringPoints = [];
      for (let i = 0; i <= segments; i += 1) {
        const angle = (i / segments) * Math.PI * 2;
        ringPoints.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
      }

      const ringGeometry = new THREE.BufferGeometry().setFromPoints(ringPoints);
      const ringMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
      raGroup.add(new THREE.LineLoop(ringGeometry, ringMaterial));

      const majorTickMaterial = new THREE.LineBasicMaterial({ color: 0x66ffff });
      const minorTickMaterial = new THREE.LineBasicMaterial({ color: 0x2d9da4 });

      for (let h = 0; h < 24; h += 1) {
        const angle = -(h / 24) * Math.PI * 2;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const majorStart = new THREE.Vector3(cosA * (radius - 0.65), 0, sinA * (radius - 0.65));
        const majorEnd = new THREE.Vector3(cosA * (radius + 0.65), 0, sinA * (radius + 0.65));
        const tickGeometry = new THREE.BufferGeometry().setFromPoints([majorStart, majorEnd]);
        raGroup.add(new THREE.Line(tickGeometry, majorTickMaterial.clone()));

        const label = `${String(h)}h`;
        const sprite = createTextSprite(label, h % 6 === 0 ? "#9fffff" : "#66ffff", h % 6 === 0 ? 18 : 15);
        sprite.position.set(cosA * (radius + 2.6), 0, sinA * (radius + 2.6));
        raGroup.add(sprite);
      }

      for (let m = 0; m < 96; m += 1) {
        if (m % 4 === 0) {
          continue;
        }
        const angle = -(m / 96) * Math.PI * 2;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const start = new THREE.Vector3(cosA * (radius - 0.4), 0, sinA * (radius - 0.4));
        const end = new THREE.Vector3(cosA * (radius + 0.4), 0, sinA * (radius + 0.4));
        const tickGeometry = new THREE.BufferGeometry().setFromPoints([start, end]);
        raGroup.add(new THREE.Line(tickGeometry, minorTickMaterial.clone()));
      }

      const decGroup = new THREE.Group();
      decGroup.rotation.y = Math.PI / 2;
      raGroup.add(decGroup);

      const decPoints = [];
      for (let i = 0; i <= segments; i += 1) {
        const angle = (i / segments) * Math.PI * 2;
        decPoints.push(new THREE.Vector3(0, Math.sin(angle) * radius, Math.cos(angle) * radius));
      }
      const decGeometry = new THREE.BufferGeometry().setFromPoints(decPoints);
      const decMaterial = new THREE.LineBasicMaterial({ color: 0x40e0d0 });
      decGroup.add(new THREE.LineLoop(decGeometry, decMaterial));

      const decTickMaterial = new THREE.LineBasicMaterial({ color: 0xffd98a });
      for (let decDeg = -90; decDeg <= 90; decDeg += 10) {
        const phi = THREE.MathUtils.degToRad(decDeg);
        const y = Math.sin(phi) * radius;
        const z = Math.cos(phi) * radius;

        const tickStart = new THREE.Vector3(-0.35, y, z);
        const tickEnd = new THREE.Vector3(0.35, y, z);
        const tickGeometry = new THREE.BufferGeometry().setFromPoints([tickStart, tickEnd]);
        decGroup.add(new THREE.Line(tickGeometry, decTickMaterial.clone()));

        const labelText = `${decDeg}\u00b0`;
        const labelColor = "#40e0d0";
        const sprite = createTextSprite(labelText, labelColor, 14);
        const radial = new THREE.Vector3(0, y, z).normalize().multiplyScalar(radius + 1.6);
        sprite.position.copy(radial);
        sprite.position.x += 1.0;
        decGroup.add(sprite);
      }
    }


    function parsePlanetsCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      const parsed = [];

      for (let i = 1; i < lines.length; i += 1) {
        const parts = lines[i].split(",");
        if (parts.length < 5) {
          continue;
        }

        const name = parts[1].trim();
        const raDeg = Number(parts[2]);
        const decDeg = Number(parts[3]);
        const distPc = Number(parts[4]);
        if (!Number.isFinite(raDeg) || !Number.isFinite(decDeg) || !Number.isFinite(distPc)) {
          continue;
        }

        const distanceLy = distPc * PARSEC_TO_LIGHTYEAR;
        const ra = (raDeg * Math.PI) / 180;
        const dec = (decDeg * Math.PI) / 180;
        const cosDec = Math.cos(dec);

        parsed.push({
          name,
          type: "Unknown",
          raDeg,
          decDeg,
          distanceLy,
          position: new THREE.Vector3(
            distanceLy * cosDec * Math.cos(ra),
            distanceLy * Math.sin(dec),
            -distanceLy * cosDec * Math.sin(ra)
          )
        });
      }

      return parsed;
    }

    function updateStatusForSelection(planet) {
      if (!planet) {
        statusEl.textContent = "No planet selected.";
        nameEl.textContent = "None";
        classEl.textContent = "-";
        raEl.textContent = "-";
        decEl.textContent = "-";
        selectionDistanceEl.textContent = "-";
        return;
      }

      statusEl.textContent = `Selected ${planet.name}.`;
      nameEl.textContent = planet.name;
      classEl.textContent = planet.type || "Unknown";
      raEl.textContent = formatRaHms(planet.raDeg);
      decEl.textContent = formatDecDms(planet.decDeg);
      selectionDistanceEl.textContent = `${planet.distanceLy.toFixed(2)} ly`;
    }

    function formatRaHms(raDeg) {
      if (!Number.isFinite(raDeg)) {
        return "-";
      }
      let totalSeconds = (raDeg / 15) * 3600;
      totalSeconds = ((totalSeconds % 86400) + 86400) % 86400;
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = Math.floor(totalSeconds % 60);
      return `${String(hours).padStart(2, "0")}h ${String(minutes).padStart(2, "0")}m ${String(seconds).padStart(2, "0")}s`;
    }

    function formatDecDms(decDeg) {
      if (!Number.isFinite(decDeg)) {
        return "-";
      }
      const sign = decDeg >= 0 ? "+" : "-";
      const abs = Math.abs(decDeg);
      const degrees = Math.floor(abs);
      const minutesFull = (abs - degrees) * 60;
      const minutes = Math.floor(minutesFull);
      const seconds = Math.floor((minutesFull - minutes) * 60);
      return `${sign}${String(degrees).padStart(2, "0")}Â° ${String(minutes).padStart(2, "0")}m ${String(seconds).padStart(2, "0")}s`;
    }

    function applyFilters() {
      const maxDistanceLy = Number(distanceRangeEl.value);
      const typeFilter = planetTypeEl.value;

      let visibleCount = 1;

      for (const mesh of planetGroup.children) {
        const planet = mesh.userData;
        const typeMatch = typeFilter === "all" || planet.typeSlug === typeFilter;
        const visible = planet.distanceLy <= maxDistanceLy && typeMatch;
        mesh.visible = visible;
        if (visible) {
          visibleCount += 1;
        }
      }

      earthMesh.visible = 0 <= maxDistanceLy;
      galacticCenterMesh.visible = true;
      raGroup.visible = showAxesEl.checked;
      galacticCenterArrow.visible = showGalacticArrowEl.checked;
      const showRaLabels = showLabelsEl.value === "yes";
      for (const obj of raGroup.children) {
        if (obj.userData?.isOverlayLabel) {
          obj.visible = showRaLabels;
        }
      }
      distanceSummaryEl.textContent = `${maxDistanceLy} ly max (${visibleCount}/${planets.length + 1} shown)`;

      if (selectedPlanet && selectedPlanet !== earthMesh && !selectedPlanet.visible) {
        selectedPlanet = null;
        updateStatusForSelection(null);
      }
      updatePlanetBaseColors(getCurrentGridWorldRadius());
    }

    function resetPlanetMeshes() {
      while (planetGroup.children.length > 0) {
        const mesh = planetGroup.children[0];
        planetGroup.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
    }

    function buildPlanetMeshes(parsedPlanets) {
      resetPlanetMeshes();

      const planetGeometry = new THREE.SphereGeometry(pointRadius, 12, 12);
      const defaultMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

      for (const planet of parsedPlanets) {
        const mesh = new THREE.Mesh(planetGeometry.clone(), defaultMaterial.clone());
        mesh.position.copy(planet.position);
        mesh.userData = {
          name: planet.name,
          type: planet.type,
          typeSlug: "unknown",
          raDeg: planet.raDeg,
          decDeg: planet.decDeg,
          distanceLy: planet.distanceLy,
          isEarth: false
        };
        planetGroup.add(mesh);
      }
    }

    async function loadPlanets() {
      try {
        if (window.location.protocol === "file:") {
          throw new Error(
            "This page is opened with file://, so browsers block reading planets.csv. Start a local server and open http://localhost instead."
          );
        }

        const response = await fetch("./planets.csv", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load planets.csv (${response.status})`);
        }

        const csvText = await response.text();
        planets = parsePlanetsCsv(csvText);
        buildPlanetMeshes(planets);

        const maxDistanceLy = planets.reduce((max, planet) => Math.max(max, planet.distanceLy), 0);
        axisRange = Math.max(100, Math.ceil(maxDistanceLy / 50) * 50);
        buildRaVisualizer();

        distanceRangeEl.min = "1";
        distanceRangeEl.max = String(Math.ceil(maxDistanceLy));
        distanceRangeEl.step = "1";
        distanceRangeEl.value = String(Math.max(1, Math.min(100, Math.ceil(maxDistanceLy))));

        updateZoomLimits();
        controls.update();

        statusEl.textContent = `Loaded ${planets.length + 1} planets. Drag to orbit, right-drag to pan, scroll to zoom.`;
        applyFilters();
      } catch (error) {
        statusEl.textContent = `Could not load planets.csv: ${error.message}`;
        classEl.textContent = "Run local server";
        nameEl.textContent = "localhost:8000";
        distanceSummaryEl.textContent = "python -m http.server 8000";
      }
    }

    function pickPlanet(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const candidates = [earthMesh, ...planetGroup.children.filter((mesh) => mesh.visible)];
      candidates.push(galacticCenterMesh);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(candidates, false);

      if (!hits.length) {
        selectedPlanet = null;
        updateStatusForSelection(null);
        updatePlanetBaseColors(getCurrentGridWorldRadius());
        return;
      }

      const next = hits[0].object;
      selectedPlanet = next;
      updateStatusForSelection(selectedPlanet.userData);
      updatePlanetBaseColors(getCurrentGridWorldRadius());
    }

    function resizeRendererToDisplaySize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      if (canvas.width !== width || canvas.height !== height) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        updateZoomLimits();
      }
    }

    function updateZoomLimits() {
      const viewportHeight = Math.max(1, canvas.clientHeight);
      const fovRad = THREE.MathUtils.degToRad(camera.fov);
      const distanceForMaxGridRadius =
        (MAX_ZOOM_OUT_GRID_RADIUS_LY * viewportHeight) /
        (2 * Math.tan(fovRad * 0.5) * RA_TARGET_SCREEN_RADIUS_PX);

      controls.maxDistance = Math.max(250, distanceForMaxGridRadius);
      camera.far = Math.max(20000, controls.maxDistance * 2);
      camera.updateProjectionMatrix();
    }

    function updatePlanetScreenSizes() {
      const viewportHeight = Math.max(1, canvas.clientHeight);
      const fovRad = THREE.MathUtils.degToRad(camera.fov);
      const meshes = [earthMesh, galacticCenterMesh, ...planetGroup.children];

      for (const mesh of meshes) {
        const distanceToCamera = camera.position.distanceTo(mesh.position);
        const frustumHeightAtMesh = 2 * distanceToCamera * Math.tan(fovRad * 0.5);
        const worldPerPixel = frustumHeightAtMesh / viewportHeight;
        const minWorldRadius = Math.max(0.0001, worldPerPixel * PLANET_MIN_SCREEN_RADIUS_PX);
        const maxWorldRadius = Math.max(minWorldRadius, worldPerPixel * PLANET_SCREEN_RADIUS_PX);
        const baseRadius = mesh.geometry?.parameters?.radius || pointRadius;
        const clampedWorldRadius = Math.min(maxWorldRadius, Math.max(minWorldRadius, baseRadius));
        mesh.scale.setScalar(clampedWorldRadius / baseRadius);
      }
    }

    function getCurrentGridWorldRadius() {
      const distanceToEarth = camera.position.distanceTo(earthMesh.position);
      const frustumHeightAtEarth =
        2 * distanceToEarth * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
      const worldPerPixel = frustumHeightAtEarth / Math.max(1, canvas.clientHeight);
      return worldPerPixel * RA_TARGET_SCREEN_RADIUS_PX;
    }

    function updatePlanetBaseColors(gridWorldRadius) {
      earthMesh.material.color.setHex(COLOR_EARTH);
      galacticCenterMesh.material.color.setHex(
        selectedPlanet === galacticCenterMesh ? COLOR_SELECTED : COLOR_GALACTIC_CENTER
      );

      for (const mesh of planetGroup.children) {
        if (mesh === selectedPlanet) {
          mesh.material.color.setHex(COLOR_SELECTED);
          continue;
        }

        const distanceFromEarth = mesh.position.distanceTo(earthMesh.position);
        const insideGrid = distanceFromEarth <= gridWorldRadius;
        mesh.material.color.setHex(insideGrid ? COLOR_PLANET_INSIDE_GRID : COLOR_PLANET_OUTSIDE_GRID);
      }
    }

    function animate() {
      resizeRendererToDisplaySize();
      updatePlanetScreenSizes();
      const targetWorldRadius = getCurrentGridWorldRadius();
      gridRadiusEl.textContent = `${targetWorldRadius.toFixed(2)} ly`;
      const scale = Math.max(0.001, targetWorldRadius / RA_BASE_RADIUS);
      raGroup.position.copy(earthMesh.position);
      raGroup.scale.setScalar(scale);
      galacticCenterArrow.position.copy(earthMesh.position);
      galacticCenterArrow.setLength(
        Math.max(12, targetWorldRadius * 0.85),
        Math.max(2.5, targetWorldRadius * 0.1),
        Math.max(1.2, targetWorldRadius * 0.05)
      );
      updatePlanetBaseColors(targetWorldRadius);
      raGroup.children.forEach((obj) => {
        if (obj.type === "Sprite") {
          obj.quaternion.copy(camera.quaternion);
        }
      });
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function resetViewToEarth() {
      controls.target.copy(earthMesh.position);
      camera.position.set(0, 120, 250);
      controls.update();
    }

    distanceRangeEl.addEventListener("input", applyFilters);
    planetTypeEl.addEventListener("change", applyFilters);
    showAxesEl.addEventListener("change", applyFilters);
    showGalacticArrowEl.addEventListener("change", applyFilters);
    showLabelsEl.addEventListener("change", applyFilters);
    resetViewEl.addEventListener("click", resetViewToEarth);

    renderer.domElement.addEventListener("mousedown", (event) => {
      if (event.button !== 0) {
        return;
      }
      pointerIsDown = true;
      pointerMoved = false;
      pointerDownX = event.clientX;
      pointerDownY = event.clientY;
    });
    window.addEventListener("mousemove", (event) => {
      if (!pointerIsDown || pointerMoved) {
        return;
      }
      const dx = event.clientX - pointerDownX;
      const dy = event.clientY - pointerDownY;
      if ((dx * dx) + (dy * dy) > 16) {
        pointerMoved = true;
      }
    });
    window.addEventListener("mouseup", () => {
      pointerIsDown = false;
    });
    renderer.domElement.addEventListener("click", (event) => {
      if (pointerMoved) {
        pointerMoved = false;
        return;
      }
      pickPlanet(event);
    });

    showAxesEl.checked = true;
    showGalacticArrowEl.checked = false;
    nameEl.textContent = "All planets";
    classEl.textContent = "From planets.csv";
    raEl.textContent = "-";
    decEl.textContent = "-";
    selectionDistanceEl.textContent = "-";
    distanceSummaryEl.textContent = "-";
    statusEl.textContent = "Loading planets.csv...";

    loadPlanets();
    animate();
  </script>
</body>
</html>
