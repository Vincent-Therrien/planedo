<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exoplanet Viewer</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Exoplanet Position Viewer</h1>
      <p class="subtitle">3D map of confirmed exoplanets</p>

      <div class="controls">
        <div class="control">
          <label for="distance-range">Max distance (ly)</label>
          <input id="distance-range" type="range" min="2" max="100" step="0.1" value="8" />
        </div>

        <div class="control">
          <label for="planet-type">Planet type</label>
          <select id="planet-type">
            <option value="all">All</option>
            <option value="gas-giant">Gas Giant</option>
            <option value="neptune-like">Neptune-like</option>
            <option value="super-earth">Super Earth</option>
            <option value="terrestrial">Terrestrial</option>
          </select>
        </div>

        <div class="control">
          <label for="show-labels">Show labels</label>
          <select id="show-labels">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div class="control axis-toggle">
          <label for="show-axes">Show axes</label>
          <input id="show-axes" type="checkbox" />
        </div>
      </div>

      <section class="planet-info" aria-live="polite">
        <h2>Selection</h2>
        <p id="selection-status">Click a sphere to see details.</p>
        <p><strong>Name:</strong> <span id="planet-name">None</span></p>
        <p><strong>Type:</strong> <span id="planet-class">-</span></p>
        <p><strong>Distance:</strong> <span id="planet-distance">-</span></p>
      </section>
    </aside>

    <main class="canvas-wrap">
      <canvas id="scene-canvas" aria-label="3D exoplanet scene"></canvas>
    </main>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const canvas = document.getElementById("scene-canvas");
    const statusEl = document.getElementById("selection-status");
    const nameEl = document.getElementById("planet-name");
    const classEl = document.getElementById("planet-class");
    const distanceEl = document.getElementById("planet-distance");
    const distanceRangeEl = document.getElementById("distance-range");
    const planetTypeEl = document.getElementById("planet-type");
    const showLabelsEl = document.getElementById("show-labels");
    const showAxesEl = document.getElementById("show-axes");

    const PARSEC_TO_LIGHTYEAR = 3.26156;
    const pointRadius = 0.75;
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    let axisRange = 100;
    let planets = [];
    let selectedPlanet = null;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 10000);
    camera.position.set(0, 120, 250);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0, 0);

    const axesHelper = new THREE.AxesHelper(100);
    axesHelper.visible = false;
    scene.add(axesHelper);

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const pointLight = new THREE.PointLight(0xffffff, 0.9);
    pointLight.position.set(120, 120, 120);
    scene.add(pointLight);

    const earthGeometry = new THREE.SphereGeometry(pointRadius * 1.4, 16, 16);
    const earthMaterial = new THREE.MeshStandardMaterial({ color: 0x2d7dff });
    const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.userData = {
      name: "Earth",
      type: "Reference",
      distanceLy: 0,
      isEarth: true
    };
    scene.add(earthMesh);

    const planetGroup = new THREE.Group();
    scene.add(planetGroup);


    function parsePlanetsCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      const parsed = [];

      for (let i = 1; i < lines.length; i += 1) {
        const parts = lines[i].split(",");
        if (parts.length < 5) {
          continue;
        }

        const name = parts[1].trim();
        const raDeg = Number(parts[2]);
        const decDeg = Number(parts[3]);
        const distPc = Number(parts[4]);
        if (!Number.isFinite(raDeg) || !Number.isFinite(decDeg) || !Number.isFinite(distPc)) {
          continue;
        }

        const distanceLy = distPc * PARSEC_TO_LIGHTYEAR;
        const ra = (raDeg * Math.PI) / 180;
        const dec = (decDeg * Math.PI) / 180;
        const cosDec = Math.cos(dec);

        parsed.push({
          name,
          type: "Unknown",
          distanceLy,
          position: new THREE.Vector3(
            distanceLy * cosDec * Math.cos(ra),
            distanceLy * Math.sin(dec),
            distanceLy * cosDec * Math.sin(ra)
          )
        });
      }

      return parsed;
    }

    function updateStatusForSelection(planet) {
      if (!planet) {
        statusEl.textContent = "No planet selected.";
        nameEl.textContent = "None";
        classEl.textContent = "-";
        return;
      }

      statusEl.textContent = `Selected ${planet.name}.`;
      nameEl.textContent = planet.name;
      classEl.textContent = planet.type || "Unknown";
    }

    function applyFilters() {
      const maxDistanceLy = Number(distanceRangeEl.value);
      const typeFilter = planetTypeEl.value;

      let visibleCount = 1;

      for (const mesh of planetGroup.children) {
        const planet = mesh.userData;
        const typeMatch = typeFilter === "all" || planet.typeSlug === typeFilter;
        const visible = planet.distanceLy <= maxDistanceLy && typeMatch;
        mesh.visible = visible;
        if (visible) {
          visibleCount += 1;
        }
      }

      earthMesh.visible = 0 <= maxDistanceLy;
      axesHelper.visible = showAxesEl.checked;
      distanceEl.textContent = `${maxDistanceLy} ly max (${visibleCount}/${planets.length + 1} shown)`;

      if (selectedPlanet && selectedPlanet !== earthMesh && !selectedPlanet.visible) {
        selectedPlanet.material.color.setHex(0xffffff);
        selectedPlanet = null;
        updateStatusForSelection(null);
      }
    }

    function resetPlanetMeshes() {
      while (planetGroup.children.length > 0) {
        const mesh = planetGroup.children[0];
        planetGroup.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
    }

    function buildPlanetMeshes(parsedPlanets) {
      resetPlanetMeshes();

      const planetGeometry = new THREE.SphereGeometry(pointRadius, 12, 12);
      const defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

      for (const planet of parsedPlanets) {
        const mesh = new THREE.Mesh(planetGeometry.clone(), defaultMaterial.clone());
        mesh.position.copy(planet.position);
        mesh.userData = {
          name: planet.name,
          type: planet.type,
          typeSlug: "unknown",
          distanceLy: planet.distanceLy,
          isEarth: false
        };
        planetGroup.add(mesh);
      }
    }

    async function loadPlanets() {
      try {
        if (window.location.protocol === "file:") {
          throw new Error(
            "This page is opened with file://, so browsers block reading planets.csv. Start a local server and open http://localhost instead."
          );
        }

        const response = await fetch("./planets.csv", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load planets.csv (${response.status})`);
        }

        const csvText = await response.text();
        planets = parsePlanetsCsv(csvText);
        buildPlanetMeshes(planets);

        const maxDistanceLy = planets.reduce((max, planet) => Math.max(max, planet.distanceLy), 0);
        axisRange = Math.max(100, Math.ceil(maxDistanceLy / 50) * 50);
        axesHelper.scale.setScalar(axisRange / 100);

        distanceRangeEl.min = "1";
        distanceRangeEl.max = String(Math.ceil(maxDistanceLy));
        distanceRangeEl.step = "1";
        distanceRangeEl.value = String(Math.max(1, Math.min(100, Math.ceil(maxDistanceLy))));

        controls.maxDistance = Math.max(250, axisRange * 8);
        controls.update();

        statusEl.textContent = `Loaded ${planets.length + 1} planets. Drag to orbit, right-drag to pan, scroll to zoom.`;
        applyFilters();
      } catch (error) {
        statusEl.textContent = `Could not load planets.csv: ${error.message}`;
        classEl.textContent = "Run local server";
        nameEl.textContent = "localhost:8000";
        distanceEl.textContent = "python -m http.server 8000";
      }
    }

    function pickPlanet(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const candidates = [earthMesh, ...planetGroup.children.filter((mesh) => mesh.visible)];
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(candidates, false);

      if (!hits.length) {
        if (selectedPlanet) {
          selectedPlanet.material.color.setHex(selectedPlanet.userData.isEarth ? 0x2d7dff : 0xffffff);
        }
        selectedPlanet = null;
        updateStatusForSelection(null);
        return;
      }

      const next = hits[0].object;
      if (selectedPlanet && selectedPlanet !== next) {
        selectedPlanet.material.color.setHex(selectedPlanet.userData.isEarth ? 0x2d7dff : 0xffffff);
      }

      selectedPlanet = next;
      selectedPlanet.material.color.setHex(0xff2a2a);
      updateStatusForSelection(selectedPlanet.userData);
    }

    function resizeRendererToDisplaySize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      if (canvas.width !== width || canvas.height !== height) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }

    function animate() {
      resizeRendererToDisplaySize();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    distanceRangeEl.addEventListener("input", applyFilters);
    planetTypeEl.addEventListener("change", applyFilters);
    showAxesEl.addEventListener("change", applyFilters);
    showLabelsEl.addEventListener("change", () => {
      statusEl.textContent =
        showLabelsEl.value === "yes"
          ? "Labels are not yet implemented for this three.js view."
          : "Labels hidden.";
    });

    renderer.domElement.addEventListener("click", pickPlanet);

    showAxesEl.checked = false;
    nameEl.textContent = "All planets";
    classEl.textContent = "From planets.csv";
    distanceEl.textContent = "-";
    statusEl.textContent = "Loading planets.csv...";

    loadPlanets();
    animate();
  </script>
</body>
</html>


